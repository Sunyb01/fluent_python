# 型变总结
## 1. 类型
- 不变类型
- 协变类型
- 逆变类型

## 2. 详解
### 1. 不变类型
不管实参之间是否存在关系, 当两个参数类型之间不存在超类型或者子类型关系时, 泛型L是不变的;
也就是说, 如果L是不变的, 那么L[A] 就不是 L[B]的超类型或子类型. 两个方向都不相容;

与之相似的是Rust中的泛型
```rs
   let x: Vec[String] = Vec::new();
   let y: Vec[i32] = Vec::new();
```

```java
    List<String> s1 = new ArrayList<>();
    List<Integer> s2 = new ArrayList<>();
```
```python
    x = list[int] 
    y = list[float]
```

### 2. 协变类型
给定两个类型A和B, B与A相容, 而且均不是Any. 
有些作者使用符号<:和:>表示类型之间的关系, 如下所示. 

A :> B 

    A是B的超类型, 或者A与B类型相同. 

B <: A 

    B是A的子类性, 或者B与A类型相同. 

对于A :> B, 当满足C[A] :> C[B]时, 泛型C是可协变的.
注意, 在前后两种情况中, :>符号的方向是相同的, A在B的左边. 协变的泛型遵循具体的类型参数的子类型关系; 整体上展示的效果类似于Java中的<T extends Obj>

### 3. 逆变类型
对于A:>B, 当满足K[A] <: K[B]时, 泛型K是可逆变的. 可逆变的泛型可以逆转具体类型参数的子类型关系.

可协变的容器通常是只写的数据结构(也叫接收器, sink). 标准库中没有这样的容器, 不过有一些类型有可逆变的类型参数.

效果上类似于Java中的<T super Obj>.

## 3. 型变经验法则
- 如果一个形式类型参数定义的是从对象中获取的数据类型, 那么该形式类型参数可能是协变的.
- 如果一个形式参数类型定义的是对象初始化之后想对象输入的数据类型, 那么该形式类型参数可能是逆变的.
- 如果一个形式类型参数定义的是从对象中获取的数据类型, 同时也是向对象中输入的数据类型, 那么该形式参数类型必定是不变的.
- 为了保险起见, 形式类型参数最好是不变的.
